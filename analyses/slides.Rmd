---
title: 'Targeting Poverty by Predicting Poverty: Using Machine Learning in Targeted
  Transfer Programs'
output: beamer_presentation
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=12, fig.height=8, fig.path='Figs/',
                      warning=FALSE, message=FALSE)
knitr::opts_knit$set(root.dir="../")
options(width = 250)
```

```{r helpers, echo=FALSE}
myround <- function(x, digits=1) {
  if(digits < 1) stop("This is intended for the case digits >= 1.")
  if(length(digits) > 1) {
    digits <- digits[1]
    warning("Using only digits[1]")
  }
  tmp <- sprintf(paste("%.", digits, "f", sep=""), x)
  # deal with "-0.00" case
  zero <- paste0("0.", paste(rep("0", digits), collapse=""))
  tmp[tmp == paste0("-", zero)] <- zero
  tmp
}

cap <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(toupper(substring(s, 1,1)), substring(s, 2),
      sep="", collapse=" ")
}
```

```{r preamble, echo=FALSE}
library(MLlibrary)
library(dplyr)
library(purrr)
library(reshape2)
library(ggplot2)
library(grid) # for unit
library(scales) # for brewer_pal
library(knitr)

THRESHOLD <- 0.4
all_names <- c('niger_pastoral', 'niger_agricultural', 'tanzania_2008', 'tanzania_2010', 'tanzania_2012', 'ghana_pe', 'mexico', 'south_africa_w1', 'south_africa_w2', 'south_africa_w3', 'iraq', 'brazil')
# all_names <- c('niger_pastoral', 'niger_agricultural', 'tanzania_2008')
countries <- strsplit(all_names, '_') %>% 
  map(first) %>%
  unique() %>%
  map(cap)

# pmt_names <- c('niger_pastoral_pmt', 'niger_agricultural_pmt', 'ghana')
pmt_names <- c()
renames <- list(
  niger_pastoral='niger_1',
  niger_agricultural='niger_2',
  ghana_pe='ghana',
  ghana='ghana_pmt',
  south_africa_w1='sa_08',
  south_africa_w2='sa_10',
  south_africa_w3='sa_12',
  tanzania_2008='tnz_08',
  tanzania_2010='tnz_10',
  tanzania_2012='tnz_12'
  )

clean_name <- function(name) {
  new_name <- renames[[name]]
  if (!is.null(new_name)) {
    return(new_name)
  }
  else {
    return(name)
  }
}
```



```{r util, echo=FALSE}
table_stats <- function(tables) {
  lapply(names(tables), function(name) {
    df <- tables[[name]]
    value_name <- colnames(df)[[2]]
    df$dataset <- name
    reshape::cast(df, dataset ~ method, value=value_name)
  })
}
```

```{r daataset_stats, echo=FALSE}
ds_stats <- lapply(c(all_names, pmt_names), function(name) {
  df <- load_dataset(name)
  row_count <- nrow(df)
  col_count <- ncol(df)
  data.frame(dataset=clean_name(name), N=row_count, K=col_count)
})
ds_stats <- bind_rows(ds_stats)
```

```{r table, echo=FALSE}
get_reaches <- function(ds_names) {
  reaches <- lapply(ds_names, function(name) {
    output <- load_validation_models(name)
    reach_by_pct_targeted(output, threshold=THRESHOLD)
  })
  names(reaches) <- sapply(ds_names, clean_name)
  reaches 
}

get_reach_table <- function(reaches) {
  tables <- lapply(reaches, table_stat)
  combine_tables(tables) %>%
    select(dataset, N, K, ols, enet, forest, opf, ensemble) %>%
    rename(ols_plus_forest=opf)
}

get_budget_table <- function(reaches) {
  tables <- lapply(reaches, budget_change)
  combine_tables(tables)
}

combine_tables <- function(tables) {
  table_stats(tables) %>%
    bind_rows() %>%
    merge(ds_stats, by='dataset') %>%
      select(dataset, N, K, ols, everything()) %>%
      arrange(N)
}

difference_table <- function(reaches) {
  reach_table <- get_reach_table(reaches)
  reach_differences <- reach_table %>%
    mutate(reach_improvement=ensemble-ols) %>%
    mutate(relative_reach_improvement=(ensemble-ols)/ols) %>%
    select(N, K, dataset, reach_improvement, relative_reach_improvement)
  budget_table <- get_budget_table(reaches) %>%
    mutate(budget_reduction=-1 * ensemble) %>%
    select(dataset, budget_reduction)
  merge(reach_differences, budget_table, by='dataset') %>%
    arrange(N)
}

plot_reach_vs_pct_targeted <- function(dsname, threshold=DEFAULT_THRESHOLDS, target=NULL) {
  zoomtheme <- theme(legend.position="none", axis.line=element_blank(),axis.text.x=element_blank(),
                   axis.text.y=element_blank(),axis.ticks=element_blank(),
                   axis.title.x=element_blank(),axis.title.y=element_blank(),
                   panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
                   panel.background = element_rect(color='gray', fill="white"),
                   plot.margin = unit(c(-6,0,-6,-6),"mm"),
                   strip.background=element_blank(),
                   strip.text=element_blank())
  
  output <- load_validation_models(dsname)
  country_reach <- reach_by_pct_targeted(output, threshold=threshold)
  to_plot <- filter(country_reach, method %in% c('ols', 'ensemble'))
  p <- ggplot(to_plot, aes(x=pct_targeted, y=value, color=method)) +
    geom_line() +
    facet_wrap(~ threshold) +
    scale_color_brewer(type='qual', palette=2) +
    ylab('true poor reached (as pct of popuation)') +
    xlab('pct targeted')
  if (length(threshold)==1) {
    ols_reach <- filter(ungroup(to_plot), method=='ols')
    ols_value <- value_at_pct(ols_reach)[[1]]
    ensemble_reach <- filter(ungroup(to_plot), method=='ensemble')
    ensemble_value <- value_at_pct(ensemble_reach)[[1]]
    budget <- filter(budget_change(to_plot), method=='ensemble')[, 2]
    ensemble_pct_targeted <- threshold + budget * threshold
    xmin <- threshold + .005
    xmax <- .9
    width <- xmax - xmin
    ymin <- .1
    ymax <- ols_value + .005
    height <- ymax - ymin
    mag <- 35
    p.zoom <- p + 
      coord_cartesian(xlim = c(threshold-width/mag, threshold+width/mag), ylim=c(ols_value-height/mag, ols_value+height/mag)) +
      geom_segment(x=threshold, xend=threshold, y=ensemble_value, yend=ols_value, color='black') +
      geom_segment(y=ols_value, yend=ols_value, x=threshold, xend=ensemble_pct_targeted, color='black') +
      annotate("text", label='Delta~budget', x=threshold-(threshold-ensemble_pct_targeted)/2, y=ols_value-.0005, parse=TRUE) +
      annotate("text", label='Delta~reach', x=threshold-.001, y=ensemble_value-(ensemble_value-ols_value)/2, parse=TRUE, angle=90) +
      zoomtheme
    g <- ggplotGrob(p.zoom)
    p <- p + annotation_custom(g, xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)
  }
  p
}

reaches <- get_reaches(all_names)
reacht <- get_reach_table(reaches)
difft  <- difference_table(reaches)
```

Targeting
===============
* Machine learning is being used to improve the accuracy of targeting across a wide range of fields.
* Search engines are paid whenever a user clicks an ad. Google and Microsoft use machine learning systems to decide which ads to display to each user.
* Poverty targeting is the quintessential prediction problem in development economics.
* Can we use machine learning to better identify the poor?


Proxy Means Testing
===============
* Identifying the poor is difficult in developing countries. Household welfare is assessed through a time-consuming consumption survey. We cannot directly calculate consumption for an entire population.
* Proxy means testing (PMT) is a popular method for targeting the poor. Easy to observable household characteristics are used as statistical proxies for consumption.
* Proxy means is not the only targeting method.
    + Community targeting: Communities or local leaders select beneficiaries.
    + Self targeting: Use requirements which differentially encourage the poor to participate.


Forecasting
===============
* The statistical method behind existing PMTs is OLS
* In many situations, OLS is not the optimal predictive method.
* Regularized linear methods like ridge and LASSO reduce overfitting.
* Nonlinear methods like decision trees can capture more complex relationships.

Research Design
==============
* We compared the targeting performance of OLS to selected machine learning methods using cross-validation on household survey data from `r length(countries)` countries.
* Our research was divided into an exploratory phase and a validation phase.
    + In the exploratory phase we tested a wide range of methods on data from 4 countries: Niger, Tanzania, Ghana and Mexico. Methods included OLS, stepwise OLS, boosted trees, regression trees, PCA + k nearest neighbors, classification trees, logistic lasso, splines, random forests and ensembles.
    + To avoid over-fitting, we selected a small number of well-performing or representative methods and tested them on 3 holdout countries: South Africa, Iraq and Brazil.
  
Datasets
===============
* We used household survey data from `r length(countries)` countries: `r paste(countries, collapse=', ')`
* Datasets varied in number of observations and the number and kind of household characteristics included.
* (TODO add poverty rates + mean consumption)

---------------
```{r datasets, echo=FALSE, fig.height=4}
to_print <- ds_stats %>%
  filter(!grepl('pmt', dataset)) %>%
  arrange(N)
kable(to_print)
```
  

Methods
==============
* OLS
* Elastic net (regularized least squares)
* Random forests
* OLS with random forests on residuals
* Ensemble of OLS, random forests, OLS + RF


Metrics
===============
We think of poverty targeting as a classification problem and focus on two metrics of success:

  + *Reach*: Number of true poor successfully targeted
  + *Budget*: Necessary number of people targeted in order to achieve a certain reach
  
```{r metrics2, echo=FALSE, fig.height=6}
plot_reach_vs_pct_targeted('ghana_pe', threshold=.4) 
```

Poverty Thresholds
===============
TODO[Jack]: Realistic poverty thresholds
  

Results
================
```{r results, echo=FALSE}

df <- melt(reacht, id=c('dataset', 'N', 'K'))
df$dataset <- factor(df$dataset, levels=ds_stats$dataset)
ggplot(df, aes(ymax=value, y=value, upper=value, middle=variable, x=dataset, fill=variable)) + 
  geom_boxplot(position=position_dodge(width=.72), width=.7, lwd=.1, fatten=10, lower=0) + 
  scale_fill_brewer(type='qual', palette=2) +
  ylab('reach') +
  coord_cartesian(ylim=c(.25, .4))
```

Ensembles outperform OLS
==============
```{r ensemble, echo=FALSE}
df <- rename(difft, reach=relative_reach_improvement, budget=budget_reduction)
df <- melt(df, id=c('dataset', 'N', 'K'))
df <- filter(df, variable != 'reach_improvement')
df$dataset <- factor(df$dataset, levels=ds_stats$dataset)
ggplot(df, aes(y=value, x=dataset, fill=variable)) + 
  geom_bar(position=position_dodge(width=0.5), width=.4, stat='identity') + 
  scale_fill_manual(values=c('#33a02c', '#b2df8a')) +
  ylab(expression(frac(ensemble - ols, ols)))
```

Benefit from regularization decreases as N / K increases
===============
```{r reg, echo=FALSE}
ggplot(reacht, aes(y=enet-ols, x=N / K, color=dataset)) + 
  geom_point(size=4) +
  scale_color_brewer(type='qual', palette=3) +
  scale_x_log10() +
  xlab('log(N/k)')
```

Random forests are well-approximated by OLS
==============

* We are interested in whether random forests find nonlinear relationships that OLS does not find. To test this we take the predictions $\hat{y}$ made by our random forest models along with the predictors $X$. We fit a new linear model $\hat{y} = X\beta + \epsilon$.
* We find that a linear model can very-well approximate the random forest predictions, as measured by $r^2$.

```{r forest, echo=FALSE, fig.height=5}
forests <- lapply(all_names, function(name) {
  df <- load_dataset(name)
  df <- df[order(df[, TARGET_VARIABLE]), ]
  df$X <- NULL
  output <- load_validation_models(name) %>%
    filter(method=='forest') %>%
    arrange(true)
  tol <- .0001
  merged <- df
  if (nrow(merged) == nrow(output)) {
    if (all(abs(merged[, TARGET_VARIABLE] - output$true) < tol)) {
      merged[, TARGET_VARIABLE] <- output$predicted
    }
  } else {
    merged[, TARGET_VARIABLE] <- output$predicted[match(df[, TARGET_VARIABLE], output$true)]
  }
  model <- fit_ols(merged)
  rsq <- summary(model)$r.squared
  data.frame(dataset=clean_name(name), N=nrow(df), K=ncol(df), rsq=rsq)
})
forests <- rbind_all(forests)
forests$dataset <- factor(forests$dataset, levels=ds_stats$dataset)
ggplot(forests, aes(y=rsq, x=dataset, fill=dataset)) + 
  geom_bar(stat='identity') +
  scale_fill_brewer(type='qual', palette=3) +
  guides(fill=FALSE) +
  ylab(expression(r^2)) +
  coord_cartesian(ylim=c(0.5, 1)) +
  ylim(0, 1)
```



Improvements are meaningful
==============
TODO[Jack]

```{r comments, echo=FALSE}
# Notes:
# Be clearer on wording of definitions of reach and budget slide with pictoral explanation also faceted
# One slide on realistic poverty thresholds
# Rename ghana, niger
# Combine slides 3 and 4, use Paul's line, programs are already targeted, improving targeting can have a large impact
# Explain data better, also data sizes
# Training survey, targeting survey
# Slide 6 explain that OLS is unbiased
# List all methods
# Slide with summaries of datasets
# Results slide: label y axis, move ensemble to the end, width of the bars is too wide, order datasets by N
# Then show relative improvement and budget
# For forests and enet have a bullet point explaining why the graph is interesing
# Switch forest graph to bar
# N vs K
```